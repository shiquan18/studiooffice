Android 内存溢出和内存泄漏的区别

android内存管理

android应用层是由java开发的，android的davlik虚拟机与jvm也类似，只不过它是基于寄存器的。
在java中，通过new为对象分配内存，所有对象在java堆内分配空间；
而内存的释放是由垃圾收集器（GC）来回收的。 
Java采用了有向图的原理。
Java将引用关系考虑为图的有向边，有向边从 引用者指向引用对象。
线程对象可以作为有向图的起始顶点，该图就是从起始顶点(GC roots)开始的一棵树，根顶点可以到达的对象都是有效对象，GC不会回收这些对象。
如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被GC回收。


内存溢出就是你 要求分配的内存 超出了系统能给你的，系统不能满足需求，于是产生溢出。
内存溢出（out of memory）

内存溢出是指 当对象的内存占用 已经超出分配内存的空间大小，这时未经处理的异常就会抛出。
比如常见的内存溢出情况有：bitmap过大；引用没释放；资源对象没关闭

常见的Bitmap过大所导致的内存溢出
如图，这是常见的bitma对象的溢出，显示像素过高或图片尺寸远远大于显示空间的尺寸时，通常都要将其缩放，减小占用内存。


内存溢出的原因

1、内存泄露导致
由于我们程序的失误，长期保持某些资源（如Context）的引用，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成内存泄露。
Android 中常见就是Activity被引用在调用finish之后却没有释放，第二次打开activity又重新创建，这样的内存泄露不断的发生,则会导致内存的溢出。
Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。
Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，
从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程.

2、占用内存较多的对象
保存了多个耗用内存过大的对象（如Bitmap）或加载单个超大的图片，造成内存超出限制。


内存泄漏（memory leak）

有些对象只有有限的生命周期。
当它们的任务完成之后，它们将被垃圾回收。
如果在对象的生命周期本该结束的时候，这个对象还被一系列的引用，这就会导致内存泄漏。
随着泄漏的累积，app将消耗完内存。
比如，在Activity.onDestroy()被调用之后，view树以及相关的bitmap都应该被垃圾回收。
如果一个正在运行的后台线程继续持有这个Activity的引用，那么相关的内存将不会被回收，这最终将导致OutOfMemoryError崩溃。
memory leak会最终会导致out of memory！



内存泄漏
如图，这是使用MAT工具查找内存泄漏的结果，
例子是 handle 延时发送 message 而在关闭 activity 后 context 被销毁所引发的泄漏，
这是作为目的性的测试所以问题比较容易找到，在实际开发中内存泄漏不易察觉并难以找到，当泄漏累积到一定程度是会引发 OOM 的。

内存泄漏的原因
比如当你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，
结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。

1.资源对象没关闭
    如Cursor，File等资源。他们会在finalize中关闭，但这样效率太低。容易造成内存泄漏
    SQLiteCurost,当数据量大的时候容易泄漏

2.使用Adapter时，没有使用系统缓存的converView
3.没有即时调用recycle()释放不再使用的bitmap
4.使用application的context来替代activity相关的context
    不要让生命周期长于Activity的对象持有到Activity的引用
5.广播注册没取消造成内存泄露
6.Handler应该申明为静态对象， 并在其内部类中保存一个对外部类的弱引用。