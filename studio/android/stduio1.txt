9、成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用
ava中内部类主要分为
成员内部类、
局部内部类(嵌套在方法和作用域内)、
匿名内部类（没构造方法）、
静态内部类（static修饰的类，不能使用任何外围类的非static成员变量和方法， 不依赖外围类）

使用内部类最吸引人的原因是：
每个内部类都能独立地继承一个（接口的）实现，
所以无论外围类是否已经继承了某个（接口的）实现，
对于内部类都没有影响。

因为Java不支持多继承，支持实现多个接口。
但有时候会存在一些使用接口很难解决的问题，
这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。
可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。


10、string 转换成 integer的方式及原理
String integer   Intrger.parseInt(string);
Integerstring    Integer.toString();

11、哪些情况下的对象会被垃圾回收机制处理掉？
1.所有实例都没有活动线程访问。

2.没有被其他任何实例访问的循环引用实例。

3.Java 中有不同的引用类型。判断实例是否符合垃圾收集的条件都依赖于它的引用类型。

要判断怎样的对象是没用的对象。这里有2种方法：

1.采用标记计数的方法：
给内存中的对象给打上标记，对象被引用一次，计数就加1，引用被释放了，计数就减一，当这个计数为0的时候，这个对象就可以被回收了。
当然，这也就引发了一个问题：循环引用的对象是无法被识别出来并且被回收的。
所以就有了第二种方法：

2.采用根搜索算法：
从一个根出发，搜索所有的可达对象，这样剩下的那些对象就是需要被回收的


12、静态代理和动态代理的区别，什么场景使用？
静态代理类：
由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。
动态代理类：
在程序运行时，运用反射机制动态创建而成。


14、Java中实现多态的机制是什么？
答：
方法的重写Overriding
和
重载Overloading
是Java多态性的不同表现

重写Overriding是
父类与子类之间多态性的一种表现
重载Overloading是
一个类中多态性的一种表现.


16、说说你对Java反射的理解
JAVA反射机制是在
运行状态中, 对于任意一个类, 都能够知道这个类的所有属性和方法; 
对于任意一个对象, 都能够调用它的任意一个方法和属性。     
从对象出发，通过反射（Class类）可以取得类的完整信息
（类名 Class类型，所在包、具有的所有方法 Method[]类型、
某个方法的完整信息（包括修饰符、返回值类型、异常、参数类型）、
所有属性 Field[]、某个属性的完整信息、构造器 Constructors），
调用类的属性或方法自己的总结： 
在运行过程中获得类、对象、方法的所有信息。


17、说说你对Java注解的理解
元注解
元注解的作用就是  负责注解其他注解。
java5.0的时候，定义了4个标准的meta-annotation类型，它们用来提供对其他注解的类型作说明。
1.@Target
2.@Retention
3.@Documented
4.@Inherited

18、Java中String的了解
在源码中string是用final 进行修饰，
它是不可更改，
不可继承的常量。

19、String为什么要设计成不可变的？
1、字符串池的需求
字符串池是方法区（Method Area）中的一块特殊的存储区域。
当一个字符串已经被创建并且该字符串在 池 中，
该字符串的引用会立即返回给变量，
而不是重新创建一个字符串再将引用返回给变量。
如果字符串不是不可变的，那么改变一个引用（如: string2）
的字符串将会导致另一个引用（如: string1）出现脏数据。

2、允许字符串缓存哈希码
在java中常常会用到字符串的哈希码，
例如： HashMap 。String的不变性保证哈希码始终一，
因此，他可以不用担心变化的出现。 
这种方法意味着不必每次使用时都重新计算一次哈希码——这样，效率会高很多。

3、安全
String广泛的用于java 类中的参数，
如：网络连接（Network connetion），
打开文件（opening files ）等等。
如果String不是不可变的，网络连接、文件将会被改变——这将会导致一系列的安全威胁。
操作的方法本以为连接上了一台机器，但实际上却不是。
由于反射中的参数都是字符串，同样，也会引起一系列的安全问题。

20、Object类的equal和hashCode方法重写，为什么？
首先equals与hashcode间的关系是这样的：
1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；
2、如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)
由于为了提高程序的效率才实现了hashcode方法，
先进行hashcode的比较，如果不同，那没就不必在进行equals的比较了，
这样就大大减少了equals比较的次数，这对比需要比较的数量很大的效率提高是很明显的

21、List,Set,Map的区别
Set是最简单的一种集合。
集合中的
对象不按特定的方式排序，
并且没有重复对象。
Set接口主要实现了两个实现类：
HashSet： HashSet类按照哈希算法来存取集合中的对象，存取速度比较快
TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。

List的特征是其
元素以线性方式存储，
集合中可以存放重复对象。
ArrayList() : 代表长度可以改变得数组。可以对元素进行随机的访问，
向ArrayList()中插入与删除元素的速度慢。

LinkedList(): 在实现中采用链表数据结构。
插入和删除速度快，访问速度慢。

Map 是一种把键对象和值对象映射的集合，
它的每一个元素都包含一对键对象和值对象。 
Map没有继承于Collection接口 
从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。

HashMap：Map基于散列表的实现。
插入和查询“键值对”的开销是固定的。
可以通过构造器设置容量capacity和负载因子load factor，以调整容器的性能。

LinkedHashMap： 类似于HashMap，
但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。
只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。

TreeMap ： 基于红黑树数据结构的实现。查看“键”或“键值对”时，
它们会被排序(次序由Comparabel或Comparator决定)。
TreeMap的特点在 于，你得到的结果是经过排序的。
TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。

WeakHashMao ：弱键(weak key)Map，Map中使用的对象也被允许释放: 这是为解决特殊问题设计的。
如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。

26、ArrayMap和HashMap的对比
1、存储方式不同
HashMap内部有一个HashMapEntry<K, V>[]对象，每一个键值对都存储在这个对象里，当使用put方法添加键值对时，就会new一个HashMapEntry对象，
2、添加数据时扩容时的处理不一样，进行了new操作，重新创建对象，开销很大。ArrayMap用的是copy数据，所以效率相对要高。
3、ArrayMap提供了数组收缩的功能，在clear或remove后，会重新收缩数组，是否空间
4、ArrayMap采用二分法查找；

29、HashMap和HashTable的区别
1 HashMap不是线程安全的，效率高一点、方法不是Synchronize的要提供外同步，有containsvalue和containsKey方法。
hashtable是，线程安全，不允许有null的键和值，效率稍低，方法是是Synchronize的。有contains方法方法。Hashtable 继承于Dictionary 类

30、HashMap与HashSet的区别
hashMap:HashMap实现了Map接口,HashMap储存键值对,使用put()方法将元素放入map中,HashMap中使用键对象来计算hashcode值,HashMap比较快，因为是使用唯一的键来获取对象。
HashSet实现了Set接口，HashSet仅仅存储对象，使用add()方法将元素放入set中，HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false。HashSet较HashMap来说比较慢。

31、HashSet与HashMap怎么判断集合元素重复？
HashSet不能添加重复的元素，当调用add（Object）方法时候，
首先会调用Object的hashCode方法判hashCode是否已经存在，如不存在则直接插入元素；如果已存在则调用Object对象的equals方法判断是否返回true，如果为true则说明元素已经存在，如为false则插入元素。

33、ArrayList和LinkedList的区别，以及应用场景
ArrayList是基于数组实现的，ArrayList线程不安全。
LinkedList是基于双链表实现的：
使用场景：
（1）如果应用程序对各个索引位置的元素进行大量的存取或删除操作，ArrayList对象要远优于LinkedList对象；
( 2 ) 如果应用程序主要是对列表进行循环，并且循环时候进行插入或者删除操作，LinkedList对象要远优于ArrayList对象；

34、数组和链表的区别
数组：是将元素在内存中连续存储的；它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效率比较高；它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低。
链表：是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）

35、开启线程的三种方式？
ava有三种创建线程的方式，分别是继承Thread类、实现Runable接口和使用线程池

36、线程和进程的区别？
线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。
不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。
别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

38、run()和start()方法区别
这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。
start()方法被用来启动新创建的线程，
而且start()内部调用了run()方法，
这和直接调用run()方法的效果不一样

当你调用run()方法的时候，只会是在原来的线程中调用，
没有新的线程启动，start()方法才会启动新线程。


39、如何控制某个方法允许并发访问线程的个数？
semaphore.acquire() 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）
semaphore.release() 释放一个信号量，此时信号量个数+1

40、在Java中wait和seelp方法的不同；
Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。

41、谈谈wait/notify关键字的理解
等待对象的同步锁,需要获得该对象的同步锁才可以调用这个方法,否则编译可以通过，但运行时会收到一个异常：IllegalMonitorStateException。
调用任意对象的 wait() 方法导致该线程阻塞，该线程不可继续执行，并且该对象上的锁被释放。
唤醒在等待该对象同步锁的线程(只唤醒一个,如果有多个在等待),注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
调用任意对象的notify()方法则导致因调用该对象的 wait()方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。

42、什么导致线程阻塞？线程如何关闭？
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。
一种是调用它里面的stop()方法
另一种就是你自己设置一个停止线程的标记 （推荐这种）

43、如何保证线程安全？
1.synchronized；
2.Object方法中的wait,notify；
3.ThreadLocal机制   来实现的。

44、如何实现线程同步？
1、synchronized关键字修改的方法。2、synchronized关键字修饰的语句块3、使用特殊域变量（volatile）实现线程同步

45、线程间操作List
List list = Collections.synchronizedList(new ArrayList());

46、谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解
java的对象锁和类锁：java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的

49、synchronized 和volatile 关键字的区别
1.volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2.volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3.volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
4.volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
5.volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

51、ReentrantLock 、synchronized和*volatile比较
ava在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。

53、死锁的四个必要条件？
死锁产生的原因
1. 系统资源的竞争
系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。
2. 进程运行推进顺序不合适
互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
循环等待条件: 若干进程间形成首尾相接循环等待资源的关系
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
死锁的避免与预防：
死锁避免的基本思想:
系统对进程发出每一个系统能够满足的资源申请进行动态检查,并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配。这是一种保证系统不进入死锁状态的动态策略。
理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。
死锁避免和死锁预防的区别：
死锁预防是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现,而死锁避免则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。死锁避免是在系统运行过程中注意避免死锁的最终发生。

56、什么是线程池，如何使用?
创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短的任务的程序的可扩展线程池）。

57、Java中堆和栈有什么不同？
为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。

58、有三个线程T1，T2，T3，怎么确保它们按顺序执行？
在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。
线程间通信
我们知道线程是CPU调度的最小单位。在Android中主线程是不能够做耗时操作的，子线程是不能够更新UI的。而线程间通信的方式有很多，比如广播，Eventbus，接口回掉，在Android中主要是使用handler。handler通过调用sendmessage方法，将保存消息的Message发送到Messagequeue中，而looper对象不断的调用loop方法，从messageueue中取出message，交给handler处理，从而完成线程间通信。
线程池
Android中常见的线程池有四种，FixedThreadPool、CachedThreadPool、ScheduledThreadPool、SingleThreadExecutor。
FixedThreadPool线程池是通过Executors的new FixedThreadPool方法来创建。它的特点是该线程池中的线程数量是固定的。即使线程处于闲置的状态，它们也不会被回收，除非线程池被关闭。当所有的线程都处于活跃状态的时候，新任务就处于队列中等待线程来处理。注意，FixedThreadPool只有核心线程，没有非核心线程。
CachedThreadPool线程池是通过Executors的newCachedThreadPool进行创建的。它是一种线程数目不固定的线程池，它没有核心线程，只有非核心线程，当线程池中的线程都处于活跃状态，就会创建新的线程来处理新的任务。否则就会利用闲置的线程来处理新的任务。线程池中的线程都有超时机制，这个超时机制时长是60s，超过这个时间，闲置的线程就会被回收。这种线程池适合处理大量并且耗时较少的任务。这里得说一下，CachedThreadPool的任务队列，基本都是空的。
ScheduledThreadPool线程池是通过Executors的newScheduledThreadPool进行创建的，它的核心线程是固定的，但是非核心线程数是不固定的，并且当非核心线程一处于空闲状态，就立即被回收。这种线程适合执行定时任务和具有固定周期的重复任务。
SingleThreadExecutor线程池是通过Executors的newSingleThreadExecutor方法来创建的，这类线程池中只有一个核心线程，也没有非核心线程，这就确保了所有任务能够在同一个线程并且按照顺序来执行，这样就不需要考虑线程同步的问题。
AsyncTask的工作原理
AsyncTask是Android本身提供的一种轻量级的异步任务类。它可以在线程池中执行后台任务，然后把执行的进度和最终的结果传递给主线程更新UI。实际上，AsyncTask内部是封装了Thread和Handler。虽然AsyncTask很方便的执行后台任务，以及在主线程上更新UI，但是，AsyncTask并不合适进行特别耗时的后台操作，对于特别耗时的任务，个人还是建议使用线程池。
AsyncTask提供有4个核心方法：
1、onPreExecute():该方法在主线程中执行，在执行异步任务之前会被调用，一般用于一些准备工作。
2、doInBackground(String... params):这个方法是在线程池中执行，此方法用于执行异步任务。在这个方法中可以通过publishProgress方法来更新任务的进度，publishProgress方法会调用onProgressUpdate方法，另外，任务的结果返回给onPostExecute方法。
3、onProgressUpdate(Object... values):该方法在主线程中执行，主要用于任务进度更新的时候，该方法会被调用。
4、onPostExecute(Long aLong)：在主线程中执行，在异步任务执行完毕之后，该方法会被调用，该方法的参数及为后台的返回结果。
除了这几个方法之外还有一些不太常用的方法，如onCancelled(),在异步任务取消的情况下，该方法会被调用。
源码可以知道从上面的execute方法内部调用的是executeOnExecutor()方法，即executeOnExecutor(sDefaultExecutor, params);而sDefaultExecutor实际上是一个串行的线程池。而onPreExecute()方法在这里就会被调用了。接着看这个线程池。AsyncTask的执行是排队执行的，因为有关键字synchronized，而AsyncTask的Params参数就封装成为FutureTask类，FutureTask这个类是一个并发类，在这里它充当了Runnable的作用。接着FutureTask会交给SerialExecutor的execute方法去处理，而SerialExecutor的executor方法首先就会将FutureTask添加到mTasks队列中，如果这个时候没有任务，就会调用scheduleNext()方法，执行下一个任务。如果有任务的话，则执行完毕后最后在调用 scheduleNext();执行下一个任务。直到所有任务被执行完毕。而AsyncTask的构造方法中有一个call()方法，而这个方法由于会被FutureTask的run方法执行。所以最终这个call方法会在线程池中执行。而doInBackground这个方法就是在这里被调用的。我们好好研究一下这个call()方法。mTaskInvoked.set(true);表示当前任务已经执行过了。接着执行doInBackground方法，最后将结果通过postResult(result);方法进行传递。postResult()方法中通过sHandler来发送消息，sHandler的中通过消息的类型来判断一个MESSAGE_POST_RESULT，这种情况就是调用onPostExecute(result)方法或者是onCancelled(result)。另一种消息类型是MESSAGE_POST_PROGRESS则调用更新进度onProgressUpdate。
Binder的工作机制
直观来说，Binder是Android中的一个类，它实现了IBinder接口，从IPC的角度来说，Binder是Android中的一种跨进程通信的一种方式，同时还可以理解为是一种虚拟的物理设备，它的设备驱动是／dev/binder/。从Framework角度来说，Binder是ServiceManager的桥梁。从应用层来说，Binder是客户端和服务端进行通信的媒介。
我们先来了解一下这个类中每个方法的含义：
DESCRIPTOR：Binder的唯一标识，一般用于当前Binder的类名表示。
asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转化过程是区分进程的，如果客户端和服务端位于同一个进程，那么这个方法返回的是服务端的stub对象本身，否则返回的是系统封装后的Stub.proxy对象。
asBinder()：用于返回当前Binder对象。
onTransact：该方法运行在服务端的Binder线程池中，当客户端发起跨进程通信请求的时候，远程请求通过系统底层封装后交给该方法处理。注意这个方法public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)，服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数，然后执行目标方法。当目标方法执行完毕后，就像reply中写入返回值。这个方法的执行过程就是这样的。如果这个方法返回false，客户端是会请求失败的，所以我们可以在这个方法中做一些安全验证。
Binder的工作机制但是要注意一些问题：1、当客户端发起请求时，由于当前线程会被挂起，直到服务端返回数据，如果这个远程方法很耗时的话，那么是不能够在UI线程，也就是主线程中发起这个远程请求的。
2、由于Service的Binder方法运行在线程池中，所以Binder方法不管是耗时还是不耗时都应该采用同步的方式，因为它已经运行在一个线程中了。
view的事件分发和view的工作原理
Android自定义view，我们都知道实现有三部曲，onMeasure(),onLayout(),onDraw()。View的绘制流程是从viewRoot的perfromTraversal方法开始的。它经过measure，layout，draw方法才能够将view绘制出来。其中measure是测量宽高的，layout是确定view在父容器上的摆布位置的，draw是将view绘制到屏幕上的。
Measure:
view的测量是需要MeasureSpc(测量规格)，它代表一个32位int值，高2位代表SpecMode(测量模式)，低（30）位的代表SpecSize(某种测量模式下的规格大小)。而一组SpecMode和SpeSize可以打包为一个MeasureSpec,反之，MeasureSpec可以解包得到SpecMode和SpeSize的值。SpecMode有三类：
unSpecified:父容器不对view有任何限制，要多大有多大。一般系统用这个多。
Exactly:父容器已经检测出view所需要的精确大小，这个时候，view的大小就是SpecSize所指定的值，它对应者layout布局中的math_parent或者是具体的数值
At_most:父容器指定了一个可用大小的SpecSize,view的大小不能够大于这个值，它对应这布局中的wrao_content.
对于普通的view，它的MeasureSpec是由父容器的MeasureSpec和自身的layoutParam共同决定的，一旦MeasureSpec确定后，onMeasure就可以确定view的宽高了。
View的measure过程：
onMeasure方法中有个setMeasureDimenSion方法来设置view的宽高测量值，而setMeasureDimenSion有个getDefaultSize()方法作为参数。一般情况下，我们只需要关注at_most和exactly两种情况，getDefaultSize的返回值就是measureSpec中的SpecSize,而这个值基本就是view测量后的大小。而UnSpecified这种情况，一般是系统内部的测量过程，它是需要考虑view的背景这些因素的。
前面说的是view的测量过程，而viewGroup的measure过程：
对于viewGroup来说，除了完成自己的measure过程以外，还要遍历去调用子类的measure方法，各个子元素在递归执行这个过程，viewGroup是一个抽象的类，没有提供有onMeasure方法，但是提供了一个measureChildren的方法。measureChild方法的思想就是取出子元素的layoutParams,然后通过getChildMeasureSpec来常见子元素的MeasureSpec,然后子元素在电泳measure方法进行测量。由于viewGroup子类有不同的布局方式，导致他们的测量细节不一样，所以viewGroup不能象view一样调用onMeasure方法进行测量。
注意：在activity的生命周期中是没有办法正确的获取view的宽高的，原因就是view没有测量完。
1.在onWindowFocuschanged方法中获取 ----改方法含义是view已经初始化完毕
2.View.post()方法，将润那边了投递到消息队列的尾部。
3.使用viewTreeObserver的回调来完成。
4.通过view.measure方式手动测量。

onLayout
普通的view的话，可以通过setFrame方法来的到view四个顶点的位置，也就确定了view在父容器的位置，接着就调用onLayout方法，该方法是父容器确定子元素的位置。
onDraw
该方法就是将view绘制到屏幕上。分以下几步
绘制背景，
绘制自己，
绘制child，
绘制装饰。

Android中性能优化
由于手机硬件的限制，内存和CPU都无法像pc一样具有超大的内存，Android手机上，过多的使用内存，会容易导致oom，过多的使用CPU资源，会导致手机卡顿，甚至导致anr。我主要是从一下几部分进行优化：
布局优化，绘制优化，内存泄漏优化，响应速度优化，listview优化，bitmap优化，线程优化
布局优化：工具 hierarchyviewer，解决方式：
1、删除无用的空间和层级。
2、选择性能较低的viewgroup，如Relativelayout，如果可以选择Relativelayout也可以使用LinearLayout,就优先使用
LinearLayout，因为相对来说Relativelayout功能较为复杂，会占用更多的CPU资源。
3、使用标签<include/>重用布局，<Merge/>减少层级，<viewStub/>进行预加载，使用的时候才加载。
绘制优化
绘制优化指view在ondraw方法中避免大量的耗时操作，由于ondraw方法可能会被频繁的调用。
1、ondraw方法中不要创建新的局部变量，ondraw方法被频繁的调用，很容易引起GC。
2、ondraw方法不要做耗时操作。
内存优化：参考内存泄漏。
响应优化
主线程不能做耗时操作，触摸事件5s,广播10s，service20s。
listview优化：
1、getview方法中避免耗时操作。
2、view的复用和viewholder的使用。
3、滑动不适合开启异步加载。
4、分页处理数据。
5、图片使用三级缓存。
Bitmap优化：
1、等比例压缩图片。
2、不用的图片，及时recycler掉
线程优化
线程优化的思想是使用线程池来管理和复用线程，避免程序中有大量的Thread，同时可以控制线程的并发数，避免相互抢占资源而导致线程阻塞。
其他优化
1、少用枚举，枚举占用空间大。
2、使用Android特有的数据结构，如SparseArray来代替hashMap。
3、适当的使用软引用和弱引用。
加密算法（base64、MD5、对称加密和非对称加密）和使用场景。
什么是Rsa加密？
RSA算法是最流行的公钥密码算法，使用长度可以变化的密钥。RSA是第一个既能用于数据加密也能用于数字签名的算法。
RSA算法原理如下：
1.随机选择两个大质数p和q，p不等于q，计算N=pq；
2.选择一个大于1小于N的自然数e，e必须与(p-1)(q-1)互素。
3.用公式计算出d：d×e = 1 (mod (p-1)(q-1)) 。
4.销毁p和q。
最终得到的N和e就是“公钥”，d就是“私钥”，发送方使用N去加密数据，接收方只有使用d才能解开数据内容。
RSA的安全性依赖于大数分解，小于1024位的N已经被证明是不安全的，而且由于RSA算法进行的都是大数计算，使得RSA最快的情况也比DES慢上倍，这是RSA最大的缺陷，因此通常只能用于加密少量数据或者加密密钥，但RSA仍然不失为一种高强度的算法。
使用场景：项目中除了登陆，支付等接口采用rsa非对称加密，之外的采用aes对称加密，今天我们来认识一下aes加密。
什么是MD5加密？
MD5英文全称“Message-Digest Algorithm 5”，翻译过来是“消息摘要算法5”，由MD2、MD3、MD4演变过来的，是一种单向加密算法，是不可逆的一种的加密方式。
MD5加密有哪些特点？
压缩性：任意长度的数据，算出的MD5值长度都是固定的。
容易计算：从原数据计算出MD5值很容易。
抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
MD5应用场景：
一致性验证
数字签名
安全访问认证
什么是aes加密？
高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。
